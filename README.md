# Tianchi-News-Recommend

# 数据来源
https://tianchi.aliyun.com/competition/entrance/531842/information

# code文件夹
## 最终效果较好的召回排序算法
    包含了召回、特征工程、排序的最终代码，文件输出结果的完整记录见code/log/log.dox
    召回：使用ItemCF，基于网络关系的召回和Word2Vec 向量召回，合并结果后Hit Rate达到0.367，MRR达到0.220。
    特征工程：创建了新闻特征，用户特征，用户-新闻交互特征共30项。
    负采样：从召回但未点击负样本中，按用户和新闻维度各随机采样 1-5 篇，再去重。
    排序：使用LightGBM进行排序，并进行五折交叉验证，排序后指标Hit Rate达到0.441，MRR达到0.265。
## 项目痛点：
    对比实验显示，ItemCF 召回时用用户最近点击的两条新闻，Hit Rate较全量历史记录提升13%；基于网络关系与 Word2Vec 召回，仅用用户最近一次点击新闻做召回，效果均提升约10%。
    为缓解冷启动尝试加入内容相似度，但基于新闻 embedding 向量召回效果不佳，故ItemCF未引入新闻内容相似度。  
## 项目记录
    1.数据处理：从训练集（20w）用户中随机选 5 万作为线下验证集用户，将其最后一次点击行为分离出来，作为 df_valid_query，将测试集的click_article_id = -1作为df_test_query。最终df_query包括df_valid_query和df_test_query。这时候（验证集用户val_users的最后一次点击数据提取出来）的训练集点击日志与完整的测试集点击日志合并为总历史点击记录训练数据 ，df_click 直接包含 df_train_click和df_test_click，用于训练推荐模型，而验证集用户最后一次点击记录用于评估推荐效果，该验证方式稳定且与线上指标相关性强。 
    线上验证时：
    df_click：
        o 构成：由训练集df_train_click和测试集df_test_click合并而成。先将两个数据集按行拼接（pd.concat），然后重置索引，再按照user_id和click_timestamp进行排序，最后再次重置索引。
    df_query：
        o 构成：完全由测试集用户相关数据生成。针对测试集df_test_click中的每个唯一用户user_id，创建一条记录，其中click_article_id固定设置为-1 ，并将这些记录整理成DataFrame。
    
    2.召回（计算相似度，训练word2vec时用df_click,召回时用df_query）
    o 基于 itemcf 召回：计算新闻相似度时，综合考虑新闻共现次数和点击次序关系，位置越远相关性越小。建立相似度关系后，结合相似度和位置距离衰减选择 TOP100 关联新闻，同时添加 label 作为监督学习数据，召回数据按要求排序，该方法有一定召回效果。
    第一阶段：
    先根据位置权重和items的长度计算相似度sim_dict[item][relate_item] += loc_weight  / math.log(1 + len(items))，
    第二阶段：对共现次数进行归一化处理
    sim_dict[item][relate_item] = cij / math.sqrt(item_cnt[item] * item_cnt[relate_item])，这一次考虑了相似度分数（根据位置权重和items的长度计算的）和共现次数（item_cnt[item] * item_cnt[relate_item]）。
    。为了缓解冷启动问题，在计算新闻相似度的时候可以考虑加入内容相似度。但是基于数据集给的新闻 embedding 向量表示做向量召回的效果很差劲，所以最后在 itemcf 中没有引入新闻的内容相似度。（冷启动用itemcf做）
    首先找到相似物品（最多 200 个）。排名时，考虑rank[relate_item] += wij * (0.7**loc)，考虑相似度wij和位置loc，根据排名选出 Top 100 物品。实际测试中，利用所有历史点击新闻做召回，hitrate_5 指标只有0.20，限定只用最近点击的两个新闻来做召回的话，可以大幅提升至0.33。 
    添加label作为监督学习数据。该用户在测试集中无目标物品 → label=NaN（未标注，测试集数据）。否则，默认 label=0（未点击，验证机未命中）。如果 article_id 是目标物品（出现在Top 100 物品中），则 label=1（用户点击过，验证集命中）。（数据来源于df_query）
    命中率（Hitrate）@k，表示用户点击的文章是否出现在推荐列表的前 k 个。mrr_k：平均倒数排名（Mean Reciprocal Rank），表示正确推荐的排名情况。K=5, 0.336；0.198.
    
    o 基于网络关系的召回：源自相关研究，通过用户连接新闻计算相似度，考虑共同点击用户数量和这些用户点击新闻数量对相似度的影响。基于用户点击历史召回新闻，同样利用最新一次点击新闻召回效果更佳，召回数据处理和评估指标与 itemcf 类似。
    该方法也分为两个阶段，新闻相似度计算和基于用户点击历史的新闻召回。在相似度计算阶段，通过用户将两个新闻连接起来。计算相似度时考虑两种因素：1)两个新闻的共同被点击用户过多，则相似度减少；2)共同被点击用户的点击新闻过多，相似度也要减少。类似地，在召回时只利用了最新一次点击的新闻做召回，相较于利用全量历史记录召回，效果提高了10%。
    当前正在计算相似度的文章item 与 点击过 item 的用户所点击的所有文章的相似度。点击过 item 的用户越多，用户所点击的所有文章越多，相似度越低。
    找到 item 相关的所有物品及其相似度 wij。按相似度 wij 降序排序，取前 100 个最相似的文章。累加 wij，即多个相似文章都推荐 relate_item，它的权重会更高。取前 50 个最相关物品。
    同样的，添加label作为监督学习数据。hitrate_5, mrr_5, K=5, 0.313；0.191.
    
    o w2v 向量召回：利用 Word2Vec 为新闻学习向量表示，以用户最近 1 篇交互文章为查询文章，找到最相似的 100 篇文章并转换相似度分数，排除已交互文章，选取前 50 篇推荐，也进行了 label 标注和数据排序。
    取用户最近1 篇交互文章，作为查询文章（假设最近阅读的文章最能反映兴趣）。获取该文章的向量。找到与 article_vec 最相似的 100 篇文章，返回。将向量之间的距离转换为相似度分数（2 - 距离，保证分数为正）。若 relate_item 已经被用户交互过，则不推荐。将相似文章的分数累加到 rank。选取前 50 篇相似文章。
    
    召回合并：多路召回存在重复情况，通过计算重复召回新闻数量占比做相似度参考，并对召回结果进行得分合并，对比了| hitrate_5 |的 sum、mean 和 max 三种合并方式，去重后平均每个用户召回 152 个新闻，合并后召回效果有所提升。
    
    3. 排序
    特征工程：将排序建模为二分类任务，围绕召回策略开展特征工程，分为新闻、用户、用户 - 新闻交互特征三类。新闻特征含类型、创建时间等；用户特征涉及点击新闻的各类时间差、字数等统计值；交互特征基于召回策略间接或直接得到用户 - 新闻评分，最终保存特征文件。
    | | hitrate_5 | mrr_5 |
    | 合并 | 0.3667842416414129 | 0.2196640005299097 |
    新闻特征包括：
    • 新闻类型
    • 新闻创建时间
    • 新闻字数
    用户特征包括：
    • 用户点击新闻的创建时间差的平均值
    • 用户点击新闻的点击时间差的平均值
    • 用户点击新闻的点击-创建时间差的统计值：mean，std
    • 用户点击新闻的 click_datetime_hour 统计值
    • 用户点击新闻的字数统计值
    • 用户点击新闻的创建时间统计值
    • 用户点击新闻的点击时间统计值
    • 用户新闻阅读数量
    • 用户某种类新闻阅读数量
    交互特征主要基于之前的召回策略进行，通过保存召回阶段的新闻相似度信息或向量，我们能够间接或直接得到用户对待预测新闻的评分。基于 itemcf， 网络关系和 w2v 的召回得到的只是新闻之间的相似度，需要和用户的历史点击新闻计算间接得到用户-新闻评分，采用如下方式：
    •	待预测新闻和用户所有历史点击新闻相似度按次序加权求和
    •	待预测新闻和用户最近一次点击新闻相似度
    
    模型：采用单模 LGB 进行预测，使用 GroupKFold 交叉验证策略将数据划分为 5 折，在每一折训练中划分训练集和验证集，训练模型并评估，利用 AUC 作为评估指标和早停机制，对验证集和测试集进行预测，计算特征重要性并保存模型，排序后推荐效果显著提升。 排序之后，hitrate_5 涨到0.441，mrr_5 涨到0.265。


# 一些尝试
## 1，学习别人的方法，见main.py
### 召回
    用了两种召回策略，分别是基于新闻相似度的协同过滤召回和基于新闻热度的召回。
    基于新闻相似度的协同过滤（25篇）：先构造新闻相似度矩阵，相似度为相似新闻出现的次数取对数，之后根据矩阵选出前K篇相似度最高的新闻。
    基于新闻热度的召回（10篇）：选取用户最后一次点击时刻的前一天到后一天的前K篇最热门文章推荐给用户。
    两者合并去重。
    
### 训练和预测
    负采样：由于召回的负样本过多，所以需要进行负采样。负采样使用比例0.001进行随机采样，最少1篇，最多5篇，分别从用户和新闻两个维度进行负采样。其中正样本数量为118761。
    排序模型：LGBMRanker
    训练数据：赛事提供的train_click_log和testA_click_log的前N-1次点击（由于testA中有部分用户只点击了一次，所以开始处理时已经去除。），其中80%为训练集，10%为模型使用的eval_set，10%为线下验证集，数据的最后一次点击作为预测目标。（80%是所有点击数据，不是用户数量，所以用户数量可能会有所不同）
    线下MRR：0.233

## 2，学习基础的召回、特征工程、排序方法
## baseline.py  
    为了测试代码的最终生成格式，只使用itemcf召回，然后进行用户热度补全，提交文件。最终MRR只有0.102。

## data_analyse.py
    数据加载与预处理：
        加载训练集和测试集的点击日志数据
        加载文章信息和文章embedding数据
        对用户点击数据进行基础预处理，如时间戳排序和点击次数统计
    用户行为分析：
        分析用户点击环境分布（设备、操作系统、地区等）
        统计用户重复点击行为，发现约99.2%的用户不会重复阅读同一篇文章
        分析用户活跃度，识别出活跃用户（点击次数>100）和非活跃用户（点击次数≤2）
        研究用户的新闻类型偏好，大多数用户阅读的新闻类型在20种以下
    新闻文章分析：
        分析热门和冷门新闻的分布
        研究新闻字数分布，发现大多数用户偏好阅读250字以下的文章
        分析新闻类别分布
        研究新闻的共现关系（用户连续点击的新闻对分析）
    时间特征分析：
        分析用户点击时间间隔
        研究用户点击的新闻创建时间差异
    文章相似度分析：
        使用Word2Vec模型训练文章向量（16维）
        分析用户连续点击的文章之间的相似度
    主要发现：
        用户的点击环境（设备、地区等）相对稳定
        存在明显的热门文章和冷门文章
        用户阅读偏好（如文章长度、类型）有明显的模式
        连续点击的新闻间存在一定的相关性

## retrival.py和retrival_new.py
    数据处理功能：
        提供了三种数据读取模式：Debug模式（小样本调试）、线下验证模式和线上模式
        实现了文章基本信息和embedding数据的读取和预处理
        包含了时间戳归一化等数据预处理功能
    基础工具函数：
        get_user_item_time(): 获取用户-文章-时间的映射关系
        get_item_user_time_dict(): 获取文章-用户-时间的映射关系
        get_hist_and_last_click(): 获取用户的历史点击和最后一次点击信息
        get_item_info_dict(): 获取文章属性特征字典
        get_user_hist_item_info_dict(): 获取用户历史点击文章信息
    多种召回策略实现：
        基于物品的协同过滤（ItemCF）：itemcf_sim()
        基于用户的协同过滤（UserCF）：usercf_sim()
        基于embedding的相似度召回：embdding_sim()
        YouTube DNN模型召回：youtubednn_u2i_dict()
        基于物品的推荐：item_based_recommend()
        基于用户的推荐：user_based_recommend()
    冷启动处理：
        cold_start_items(): 处理新用户或新文章的冷启动问题
        基于文章属性（类型、字数、创建时间等）进行推荐
    召回结果处理：
        combine_recall_results(): 合并多种召回策略的结果
        metrics_recall(): 评估召回结果的效果
## feature.py
    数据预处理功能：
        reduce_mem(): 优化数据内存占用的函数，通过调整数据类型来减少内存使用
        trn_val_split(): 将数据集划分为训练集和验证集
        get_hist_and_last_click(): 获取用户的历史点击和最后一次点击信息
        get_trn_val_tst_data(): 读取训练、验证和测试数据集
    Embedding相关功能：
        trian_item_word2vec(): 训练文章的Word2Vec嵌入向量
        get_embedding(): 获取各种类型的嵌入向量（内容嵌入、Word2Vec嵌入、YouTube嵌入等）
    特征生成功能：
        create_feature(): 创建特征，包括用户特征、物品特征和交互特征
        active_level(): 计算活跃度相关特征
        hot_level(): 计算热度相关特征
        device_fea(): 生成设备相关特征
        user_time_hob_fea(): 生成用户时间习惯特征
        user_cat_hob_fea(): 生成用户类别兴趣特征
    标签处理功能：
        get_rank_label_df(): 获取排序标签数据
        neg_sample_recall_data(): 负采样，用于生成训练数据
        get_user_recall_item_label_df(): 获取用户-物品-标签数据
    召回数据处理：
        get_recall_list(): 读取召回列表（支持单路召回和多路召回）
        recall_dict_2_df(): 将召回字典转换为DataFrame格式
    主要特征类型包括：
        用户特征：
            活跃度特征
            时间习惯特征
            类别兴趣特征
            设备使用特征
        文章特征：
            内容特征
            热度特征
            各种嵌入向量
        交互特征：
            用户-文章交互特征
            时序特征
            统计特征

## sort.py
    排序模型实现：
        主要包含三种排序模型：
            LGB排序模型（LGBMRanker）：使用LightGBM的排序模型
            LGB分类模型
            DIN（Deep Interest Network）深度学习分类模型
    模型训练与验证：
        实现了五折交叉验证
        使用NDCG作为评估指标
        支持早停策略
        提供了离线验证和在线预测两种模式
    结果处理功能：
        submit()：生成最终的提交结果
        norm_sim()：对排序结果进行归一化处理
        get_kfold_users()：实现用户级别的K折交叉验证
    模型融合策略：
        实现了两种模型融合方法：
        加权融合：不同模型的输出结果加权平均
        Stacking：将多个模型的预测结果作为特征，再训练一个模型
    但是最终效果不好，经过召回、特征工程和排序后，提交结果MRR仅有0.0922，甚至没有baseline的效果好。
## read.py
读取生成的文件，查看文件格式。
